<html><head><title>rxgen</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="style" type="text/css" href="../style.css" media="all" >

</head>
<body class='pod'>
<!--
  generated by OpenAFS::HTML v1.1,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.010000 at Sat Mar 29 18:17:43 2008 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to OpenAFS::HTML, and/or subclassing OpenAFS::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of OpenAFS::HTML for advice.
   See 'perldoc OpenAFS::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>rxgen - Stub generator for the Rx remote procedure call package</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>


<div class="synopsis">


<p><b>rxgen</b> [<b>-h</b> | <b>-c</b> | <b>-C</b> | <b>-S</b> | <b>-r</b>] [<b>-dkpR</b>] [<b>-I</b> <i>dir</i>] [<b>-P</b> <i>prefix</i>] [<b>-o</b> <i>outfile</i>] [<i>infile</i>]</p>

<p><b>rxgen</b> <b>-s</b> <i>transport</i> [<b>-o</b> <i>outfile</i>] [<i>infile</i>]</p>

<p><b>rxgen</b> <b>-l</b> [<b>-o</b> <i>outfile</i>] [<i>infile</i>]</p>

<p><b>rxgen</b> <b>-m</b> [<b>-o</b> <i>outfile</i>] [<i>infile</i>]</p>


</div>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><b>rxgen</b> is a tool that generates C code to implement the Rx RPC protocol; it takes as input a description of an application interface similar to C and produces a number of server and/or client stub routines to be linked with RPC-based programs.
These stubs allow programs to invoke remote procedures through local procedure calls.
<b>rxgen</b> is an extension of Sun&#39;s <b>rpcgen</b> (version 3.9) and retains full <b>rpcgen</b> functionality (at least as of that version).
Please refer to rpcgen(1) for more details on the Sun&#39;s RPC specific flags,
and to the RPC programming guide regarding the RPC language along with useful examples.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONS"
>OPTIONS</a></h1>

<p><b>rxgen</b> operates in several different modes.
The generated output files can be produced individually (using one of <b>-h</b>,
<b>-c</b>,
<b>-C</b>,
or <b>-S</b>) or collectively.
All output files are created when the default is used (i.e.,
no options),
or the output is limited to the server stubs (<b>-C</b> and <b>-S</b>) when the <b>-r</b> flag is used.
The following describes the types of generated output files (for simplicity,
<i>filename</i> refers to the main output filename):</p>

<dl>
<dt><a name="-h"
><b>-h</b></a></dt>

<dd>
<p>Generate C data definitions (a header file) from standard RPCL definitions (default extension: <i>filename</i>.h).</p>

<dt><a name="-c"
><b>-c</b></a></dt>

<dd>
<p>Compile the XDR routines required to serialize the protocol described by RPCL.
Generate XDR routines for all declarations (default extension: <i>filename</i>.xdr.c).</p>

<dt><a name="-C"
><b>-C</b></a></dt>

<dd>
<p>Generate all the client-side stub routines (default extension: <i>filename</i>.cs.c).
Calling a routine in this file will cause the arguments to be packed up and sent via Rx (or R).</p>

<dt><a name="-S"
><b>-S</b></a></dt>

<dd>
<p>Generate all the server-side stub routines (default extension: <i>filename</i>.ss.c).
Arguments are unpacked,
and the corresponding server routine is called.</p>

<dt><a name="-r"
><b>-r</b></a></dt>

<dd>
<p>Generate the two default extension files produced by the <b>-C</b> and <b>-S</b> options.</p>
</dd>
</dl>

<p>The following options can be used on any combination of <b>rxgen</b> calls:</p>

<dl>
<dt><a name="-R"
><b>-R</b></a></dt>

<dd>
<p>Generate code for the older \R protocol,
as opposed to Rx,
which is the default.</p>

<dt><a name="-k"
><b>-k</b></a></dt>

<dd>
<p>Must be specified when the generated code is intended to be used by the kernel; special &#34;includes&#34; and other specifics are produced when the target output is for the kernel.</p>

<dt><a name="-p"
><b>-p</b></a></dt>

<dd>
<p>Package combination flag: when multiple packages are included within a single specification file,
a single Execute Request routine will be used for all of them as a result of this flag.
The default is to generate individual Execute Request stubs for each package.</p>

<dt><a name="-I_dir"
><b>-I</b> <i>dir</i></a></dt>

<dd>
<p>Similar to the <b>-I</b> flag in the C compiler (<b>cc</b>).
This flag is passed to the pre-processor (<b>cpp</b>) so that directory <i>dir</i> is searched before the standard lookup list for #include files.
As expected,
multiple <b>-I</b> flags can be used simultaneously.</p>

<dt><a name="-P_prefix"
><b>-P</b> <i>prefix</i></a></dt>

<dd>
<p>The <i>prefix</i> string following this switch is prepended to all generated output files; useful when multiple runs want to produce different versions of the same interface (say,
kernel and non-kernel versions).</p>

<dt><a name="-d"
><b>-d</b></a></dt>

<dd>
<p>Debugging mode; only needed when <b>rxgen</b> is to be debugged (say,
via <b>dbx</b>).</p>

<dt><a name="-o_outfile"
><b>-o</b> <i>outfile</i></a></dt>

<dd>
<p>Specify the name of the output file.
If none is specified,
the standard output is used (<b>-c</b>,
<b>-h</b>,
<b>-C</b>,
and <b>-S</b> modes only).
Note that if an output file is specified in a multi-output file option (such as the default,
or with option <b>-r</b>),
then the <i>outfile</i> replaces the name generated by default (which is based on the configuration&#39;s main file name).</p>
</dd>
</dl>

<p>The <b>-s</b>,
<b>-l</b>,
and <b>-m</b> options are present only for <b>rpcgen</b> support.
See rpcgen(1) for information on their use.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="rxgen_SYNTAX_SUMMARY"
><b>rxgen</b> SYNTAX SUMMARY</a></h1>

<pre>    Specification file:

        &#60;Package description option&#62; |
        &#60;Prefix description option&#62; |
        &#60;StartingOpcode description option&#62; |
        &#60;SplitPrefix description option&#62; |
        &#60;Procedure description option&#62; |
        &#60;RPCL language description option&#62;

    &#60;Package description option&#62;:

        &#34;package&#34; &#60;Package_ident&#62;

    &#60;Prefix description option&#62;:

        &#34;prefix&#34; &#60;Prefix_ident&#62;

    &#60;StartingOpcode description option&#62;:

        &#34;startingopcode&#34; &#60;constant&#62;

    &#60;SplitPrefix description option&#62;:

        &#34;splitprefix&#34; &#60;split options&#62; &#34;;&#34;

    &#60;Split options&#62;:

        &#34;IN =&#34; &#60;Start_prefix_ident&#62; &#34;|&#34;
        &#34;OUT =&#34; &#60;End_prefix_ident&#62; &#34;|&#34;
        &#60;Split options&#62;

    &#60;Procedure description option&#62;:

        [&#34;proc&#34;] [&#60;Procedure_ident&#62;] [&#60;ServerStub_ident&#62;]
            &#60;Argument list&#62; [&#34;split&#34; | &#34;multi&#34;]
            [&#34;=&#34; &#60;Opcode_ident&#62;] &#34;;&#34;

    &#60;Argument list&#62;:

        &#34;(&#34; &#60;Argument definition&#62; &#60;Comma_joined argument&#62; &#34;)&#34;

    &#60;Argument definition&#62;:

        &#60;Direction option&#62; &#60;Standard RPCL type decl&#62; &#60;Arg_ident&#62;
            [&#34;&#60;&#34; &#60;Max_size&#62; &#34;&#62;&#34; | &#34;[&#34; &#60;Max_size&#62; &#34;]&#34;] | NULL

    &#60;Comma_joined argument&#62;:

        &#34;,&#34; &#60;Argument definition&#62; | NULL

    &#60;Direction option&#62;:

        &#34;IN&#34; | &#34;OUT&#34; | &#34;INOUT&#34; | NULL

    &#60;Max_size&#62;:

        &#60;constant&#62; | NULL

    &#60;Package_ident&#62;:
    &#60;Prefix_ident&#62;:
    &#60;String_ident&#62;:
    &#60;Start_prefix_ident&#62;:
    &#60;End_prefix_ident&#62;:
    &#60;Procedure_ident&#62;:
    &#60;ServerStub_ident&#62;:
    &#60;Arg_ident&#62;:
    &#60;Opcode_ident&#62;:

        &#60;identifier&#62;

    &#60;RPCL language description option&#62;:
    &#60;Standard RPCL type decl&#62;:

        Sun&#39;s RPCL language syntax (see rpcgen(1))</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="rxgen_COMMANDS"
><b>rxgen</b> COMMANDS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Comments_and_Preprocessing"
>Comments and Preprocessing</a></h2>

<p>The input interface may contain preprocessor directives which are passed through the C preprocessor (i.e. <code>cpp</code>). Since the preprocessor runs on all input files before they are actually interpreted by <b>rxgen</b>, all <b>cpp</b> directives (#include, #ifdefs, #defines, etc.) are legal and welcomed within an <b>rxgen</b> input file. Of course, none of these preprocessor directives will be included in any of the generated files. To facilitate distinctions between the different types of output files, <b>rxgen</b> defines certain special <b>cpp</b> symbols for use by the <b>rxgen</b> programmer. These are RPC_HDR (defined when compiling into header, <i>filename</i>.h, files), RPC_XDR (defined when compiling into xdr, <i>filename</i>.xdr.c, files), RPC_CLIENT (defined when compiling into client stubs, <i>filename</i>.cs.c, files), and RPC_SERVER (defined when compiling into server stubs, <i>filename</i>.ss.c, files).</p>

<p>In addition, <b>rxgen</b> does a little preprocessing of its own. Any line beginning with <code>%</code> is passed directly into the output file, uninterpreted by <b>rxgen</b>. For a more heavy en masse dumping of uninterpreted code, it would be adviced to include all such code in an <code>#include</code> file and pass it in preceded by <code>%</code>. The input interface may also contain any C-style comments which are, of course, ignored. Interpretation is token-based, thus special line-orientation of separate statements is not necessary. <b>rxgen</b> also provides a quite rich and helpful set of error reports, identifying them by exact line location and error type. Also, <b>rxgen</b> will automatically generate #include lines for standard include files, such as <em>rx/xdr.h</em> and <em>rx/rx.h</em>, along with the generated header file from this interface.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Prefixing_stub_procedures"
>Prefixing stub procedures</a></h2>

<p>The <i>package</i> statement tells <b>rxgen</b> the name of the interface package. It is used for prefixing the naming of all generated stub routines and the execute request procedure. For example:</p>

<pre>    package AFS_</pre>

<p>causes the execute request procedure to be named AFS_ExecuteRequest (Warning: in the older version an additional <code>_</code> was appended after the package name to the ExecuteRequest name; thus make sure you don&#39;t have an ExecuteRequest interface routine) and a given stub routine, say Fetch, to be actually named AFS_Fetch. Multiple package statements (current maximum size is 10) per configuration are permitted and are useful when multiple sets of interfaces are implemented (see the example at the end). Note that in such cases, use of the <b>-p</b> flag results in the generation of just one ExecuteRequest procedure which recognizes the multiple interfaces and whose name is prefixed by the first package statement. In the default case, independent ExecuteRequest procedures will be created for each packaged group of remote procedure calls.</p>

<p>The <i>prefix</i> statement supplies a name to prepend to all calls to remote procedure names in the ExecuteRequest stub routine. It is useful when the server makes RPC calls to other servers (say, for debugging purposes). For example:</p>

<pre>    prefix S</pre>

<p>causes the name <code>S</code> to be prepended to the name of all routines called from the server stubs. The server can then call the original name and get the client stubs.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rxgen_procedure_declaration"
><b>rxgen</b> procedure declaration</a></h2>

<p>The <i>proc</i> statement is the most common (and meaningful) in the <b>rxgen</b> interface. Its syntax description is:</p>

<pre>        [proc] [&#60;proc_name&#62;] [&#60;server_stub&#62;] (&#60;arg&#62;, ..., &#60;arg&#62;)
            [split | multi] [= &#60;opcode&#62;] ;</pre>

<p>where:</p>

<ul><li><p><code>proc</code> is an optional prefix of the procedure statement. This is just a stylistic item and not a required procedure delimiter.</p></li><li><p>&#60;proc_name&#62; is the name of the procedure. Note that even the name of the procedure is optional. This only makes sense when the name of the given procedure is identical to the name of the last <i>package</i> statement (i.e., <code>package RCallBack</code> and the declaration of the <code>RCallBack</code> procedure).</p></li><li><p>&#60;server_stub&#62;, if present, causes the ExecuteRequest procedure to call that stub instead of the automatically generated stub when a call with that opcode is decoded.</p></li><li><p>&#60;opcode&#62; is a constant or symbol that is the opcode for that procedure. One might use the preprocessor features (i.e., #define), the <i>const</i> RPC-language feature, or the old good constants as opcodes. Some further evaluation/processing of opcodes is done. Particularly, checks for duplicate and non-existent opcodes are performed, along with checks for &#34;holes&#34; (i.e., gaps in consecutive opcodes) in the opcode sequences. For example, we use the fact that when &#34;holes&#34; in opcodes exist, the ExecuteRequest procedure uses the <i>case</i> statement rather than the faster (and smaller, codewise) indexed array method.
<p>Also, <b>rxgen</b> defines (i.e., appends to the header file) three valuable macros for each package group: &#60;package-name&#62;LOWEST_OPCODE, &#60;package-name&#62;HIGHEST_OPCODE, and &#60;package-name&#62;NUMBER_OPCODES. These may be useful to the <b>rxgen</b> programmer. Also, notice that the <i>opcode</i> statement is an optional feature, and can be omitted. In such cases, automatic opcode numbers are generated sequentially, starting from 0.</p>

<p>One can change the initial opcode number by using the <i>startingopcode</i> (for lack of a better name) <b>rxgen</b> command. Its syntax is:</p>

<pre>    startingopcode &#60;constant&#62;</pre>

<p>where &#60;constant&#62; must be reasonable! Note that one can not mix procedures, some with opcodes and some without, nor allow opcodes after the specification of the <i>startingopcode</i> statement. <b>rxgen</b> will complain in all such cases.</p>
</p></li><li><p>The <i>argument</i> entry represents a given parameter of the procedure. Its syntax is:
<pre>    [IN | INOUT | OUT | &#60;null&#62;] &#60;type_decl&#62; &#60;arg_name&#62;
        [&#60;max&#62;|&#60;&#62;|[max]|[]]</pre>

<p>If the type is an indirect type (i.e., is followed by *), it is assumed that the pointer should be followed one level and the data pointed to is to be transmitted. This should normally be used for all structures/arrays and out parameters. A noticeable exception is when explicit array/structure maximum size is given; since no array-of-pointer declarations are allowed one should use typedefs to achieve the similar effect. The parameters could be input parameters (preceded by IN), output parameters (preceded by OUT), or input/output parameters (preceded by INOUT). If not specified, then the direction of the previous parameter in the procedure is used. (Note: the first parameter must be preceded by the directional primitive!)</p>
</p></li><li><p><code>split</code> is a hack to handle stub routines that do things such as file transfers or any other operation that has to exchange information (e.g., length of a file) before the call returns its output parameters. Because of the particular handshake that is involved when doing remote file transfer, we currently break all such calls into two client-side stub routines. The first (with the default prefix of <code>Begin</code>) is used to pass all IN and INOUT parameters to the server side. The second (with the default prefix of <code>End</code>) is used to get back the INOUT and OUT parameters from the server. Between the two calls, the user is supposed to do the appropriate calls for the file transfer. For example, the following procedure declaration in package AFS_
<pre>    Fetch (IN a, b,INOUT c, OUT d) split = FETCHOPCODE;</pre>

<p>will roughly generate the two independent client stub routines:</p>

<pre>    BeginAFS_Fetch (IN a, b, c)</pre>

<p>and</p>

<pre>    EndAFS_Fetch(OUT c, d)</pre>

<p>The <i>splitprefix</i> statement is used to change the default prefix names used by the two client-side stub generated routines when dealing with file transfer-related procedure calls. For example:</p>

<pre>    splitprefix IN=Before_ OUT=After_</pre>

<p>will cause the naming of the two client stubs for a file transfer-related routine, say Fetch(), to be Before_AFS_Fetch() and After_AFS_Fetch(), respectively.</p>
</p></li><li><p>The <code>multi</code> option is nearly identical to the <code>split</code> feature described above. The only significant visible difference is that along with the two client stubs, the standard client stub is also generated. Since the intention is to handle the multi-Rx calls, we need the whole standard procedure stub in the cases where no multi-Rx call of the procedure is performed. A side effect of the <code>multi</code> option is the generation of a special macro (i.e., <code>multi_&#60;Procedure-name&#62;</code> which passes back as arguments the <code>Begin</code> and <code>End</code> stubs in the header output file. This macro is used directly by the Rx code when a multi-Rx call of this procedure is performed.</p></li></ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="OBSOLETE_rxgen_FEATURES"
>OBSOLETE <b>rxgen</b> FEATURES</a></h2>

<p>Although the following rxgen commands are still in effect, they will soon be removed since there are better alternatives. DO NOT USE THEM!</p>

<p>The <i>special</i> statement is a temporary hack used to handle certain inefficiencies of standard xdr routines to handle some user-customized declarations. In particular, this applies to a string pointer specified as part of a declaration. For example,</p>

<pre>    special struct BBS SeqBody;</pre>

<p>tells <b>rxgen</b> that the entry <code>SeqBody</code> in the user-defined BBS xdr routine is a string (note that more than one string can be &#34;special&#34; per structure -- multiple ones are separated by commas); it will thus allocate and de-allocate space properly in the server-generated stubs that contain this structure as an IN or INOUT parameter.</p>

<p>A better alternative to <i>special</i> is the <i>customized</i> statement, which is simply the <code>customized</code> token followed by the regular declaration of a struct based on the RPCL rules. In this case, the declaration will be included in the generated header file (<b>-h</b> option) but no xdr routine will be generated for this structure -- the user will supply this. All pointer entries in this structure will be remembered so when the structure is used as an IN or INOUT in the server stub, no core leaks will occur. For example, consider</p>

<pre>    customized struct CBS {
        long Seqlen;
        char *SeqBody;
    }</pre>

<p>The <code>xdr_CBS</code> routine would be provided by the user where during the DECODE xdr opcode, appropriate space for the <code>SeqBody</code> string is allocated. Similarly, that space is freed during the FREE xdr opcode.</p>

<p>Note: Old style &#34;Array parameter specifications&#34; are not supported any more.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<p>In case there are some requirements not available by the current RPC language, one can customize some XDR routines by leaving those data types undefined. For every data type that is undefined, it will be assumed that a routine exists with the name <code>xdr_</code> prepended to it. A selected set of <b>rxgen</b> features is presented below, but for a more comprehensive one (unions, complex examples, etc) please refer to the <i>rpcgen Programming Guide</i> and <i>eXternal Data Representation: Sun Technical Notes</i>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Typedefs"
>Typedefs</a></h2>

<p>The RPC typedef statement is identical to the C typedef (i.e. <code>typedef &#60;declaration&#62;</code>). By default, most user declarations (i.e. structs, unions, etc) are automatically typedef&#39;ed by <b>rxgen</b>. Since it makes parsing simpler, its usage is recommended by <b>rxgen</b> scripts.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Strings"
>Strings</a></h2>

<p>The C <code>char *</code> string convention is kind of ambiguous, since it is usually intended to mean a null-terminated string of characters, but it could also represent a pointer to a single character, a pointer to an array of characters, etc. In the RPC language, a null-terminated string is unambiguously called a &#34;string&#34;. Examples,</p>

<pre>    string bigname&#60;&#62;;
    string name&#60;MAXNAMELEN&#62;;
    typedef string volname&#60;MAXVOLNAME&#62;;</pre>

<p>Notice that the maximum size of string can be arbitrary (like <code>bigname</code> above) or, preferably, or specified in angle brackets (i.e. <code>name</code> and <code>volname</code> above). In practice, one should always use only bounded strings in interfaces. A sample calling proc using the declarations above would be:</p>

<pre>    GetEntryByName (IN volname name, 
        OUT struct vldbentry *entry) = VL_GETENTRYBYNAME;</pre>

<p>or, of course,</p>

<pre>    GetEntryByName (IN string volname&#60;MAXVOLNAME&#62;,
        OUT struct vldbentry *entry) = VL_GETENTRYBYNAME;</pre>

<p>It is very important for the user to understand when the string parameters should be allocated and/or freed by the his/her client and/or server programs. A short analysis on string parameters handling follows (note that a similar method is used for the handling of variable length arrays as it will be shown later on):</p>

<ul><li><p>In the client side: IN and INOUT string parameters are the programmer&#39;s responsibility and should be allocated (static or via malloc) before calling the rpc and freed (if malloc was used) after the rpc&#39;s return in the user&#39;s client program; of course, for INOUT parameters, the returned string can&#39;t be bigger than the malloced input string.
<p>OUT string parameters are automatically malloced (based on the length of the returned string and not the maxsize) by the <b>rxgen</b> client stubs (in <i>filename</i>.cs.c) and must be freed by the client program; admittedly, this could be somewhat confusing since the user needs to free something that he/she didn&#39;t allocate.}</p>
</p></li><li><p>In the server side: IN and INOUT string parameters are automatically malloced (based on the size of incoming strings) by the rxgen server stubs (in <i>filename</i>.ss.c) before they are passed to the user&#39;s server procedure; that space is automatically freed just before the rxgen server stub returns; therefore the user need not do anything special for IN and INOUT string parameters.
<p>OUT string parameters must be malloced by the user&#39;s server procedure (i.e. null pointer is passed to it by the rxgen server stub) and it is automatically freed at the end of the <b>rxgen</b> server stub. Like in the client side, the OUT parameters are somewhat unorthodox (i.e. the server routine must malloc a string without ever freeing it itself; this is done by the <b>rxgen</b> server stub).</p>
</p></li></ul>

<p>Note that for INOUT and OUT string parameters, in both the client and server sides their arguments must be char of pointers (i.e. char **).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Pointers"
>Pointers</a></h2>

<p>Pointer declarations in RPC are also exactly as they are in C (i.e. <code>struct single_vldbentry *vldblist;</code>). Of course, one can&#39;t send pointers over the network, but one can use XDR pointers for sending recursive data types such as lists and trees (an example of a linked list will be demonstrated shortly).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Arrays"
>Arrays</a></h2>

<p>Fixed arrays are just like standard C array declarations (i.e. <code>struct UpdateEntry entries[20]</code>) without any side effect problems in <b>rxgen</b>. Since variable-length arrays have no explicit syntax in C, the angle-brackets are used for it and the array declarations are actually compiled into &#34;struct&#34;s. For example, declarations such as:</p>

<pre>    const   MAXBULKSIZE     = 10000;
    const   MAXENTRIES      = 100;
    opaque  bulk&#60;MAXBULKSIZE&#62;;           /* At most 10000 items */
    int     hosts&#60;&#62;;                     /* any number of items */
    typedef vldbentry blkentries&#60;100&#62;;   /* Preferable array decl */</pre>

<p>are compiled into the following structs:</p>

<pre>    struct {
        u_int   bulk_len;       /* no of items */
        char    *bulk_val;      /* pointer to array */
    } bulk;</pre>

<p>for the <code>bulk</code> array, and similarly for the <code>blkentries&#60;100&#62;</code> array,</p>

<pre>    struct {
        u_int      blkentries_len;   /* no of items in array */
        vldbentry  *blkentries_val;  /* pointer to array */
    } blkentries;</pre>

<p>Therefore the user should be aware of the &#34;magically&#34; generated structure entries such as the number of items in the array (&#60;array_name&#62;_len) and the pointer to the array (&#60;array_name&#62;_val) since some of the entries will have to be filled in from the client/server programs. A sample proc would be:</p>

<pre>    typedef vldbentry blkentries&#60;MAXENTRIES&#62;;
    proc GetBlk (OUT blkentries *vlentries) = VL_GETBLK;</pre>

<p>or, more directly,</p>

<pre>    GetBlk(OUT vldbentry vlentries&#60;MAXENTRIES&#62;) = VL_GETBLK;</pre>

<p>Note that although the latest method is preferable since one does not have to first use the typedef statement (and admittedly, programmers prefer avoiding typedefs), one should realize that <b>rxgen</b> does the structure expansion and the xdr creation implicitly; therefore the user should be aware of the <code>vldbentries_val</code> and <code>vldbentries_len</code> fields as before (see following examples).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Array_example_I_(least_desirable)"
>Array example I (least desirable)</a></h3>

<p>Procedure declaration in the interface configuration:</p>

<pre>    proc ListAttributes (IN vldblistbyattributes *attributes, 
                 INOUT blkentries *vldbentries) = VL_LISTATTRIBUTES;</pre>

<p>Sample CLIENT code:</p>

<pre>    blkentries entries, *pnt;
    entries.blkentries_len = 10;   /* max # returned entries */
    entries.blkentries_val = (vldbentry *)malloc(LEN);
                                   /* It must be set */

    code = VL_ListAttributes(&#38;attributes, &#38;entries);
    if (!code) {
        pnt = entries.blkentries_val;
        for (i=0; i &#60; entries.blkentries_len; i++, pnt++)
                display_vldbentry(pnt);
        /* Make sure you free the allocated space */
        free((char *)entries.blkentries_val);   
    }</pre>

<p>Sample SERVER code:</p>

<pre>    VL_ListAttributes(attributes, entries)
    {
        vldbentry *singleentry = entries-&#62;blkentries_val;
        entries-&#62;blkentries_len = 0;

        while (copy_to_vldbentry(&#38;vlentry, singleentry))
            singleentry++, vldbentries-&#62;entries_len++;
    }</pre>

<p>Although this method for variable-size arrays works fine, there are some major drawbacks. The array parameter (i.e. vldbentries above) must be declared as INOUT since we need to pass the max length of the expected returned array; more importantly, a big (depending on the value of <code>_len</code>) chunk of junk code is going to be transferred to the server as result of the IN(out) side-effect of the array. It&#39;s an easy and convenient method if the returned array size can be predicted from the start and when the size is quite high. This method is included as an example of erroneous use (and abuse) of <b>rxgen</b> and should not be used.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Array_example_II_(Desirable_method)"
>Array example II (Desirable method)</a></h3>

<p>Procedure declaration in the interface configuration (using Example I above):</p>

<pre>    proc ListAttributes (IN vldblistbyattributes *attributes, 
        OUT blkentries *vldbentries) = VL_LISTATTRIBUTES;</pre>

<p>Sample CLIENT code:</p>

<pre>    blkentries entries, *pnt;

    code = VL_ListAttributes(&#38;attributes, &#38;entries);
    if (!code) {
        pnt = entries.blkentries_val;
        for (i=0; i &#60; entries.blkentries_len; i++, pnt++)
                display_vldbentry(pnt);
        /* Make sure you free the allocated space (by rxgen) */
        free((char *)entries.blkentries_val);   
    }</pre>

<p>Sample SERVER code:</p>

<pre>    VL_ListAttributes(attributes, entries)
    {
        vldbentry *singleentry;
        entries-&#62;blkentries_len = 0;
        singleentry = entries-&#62;blkentries_val
            = (vldbentry *)malloc(MAXENTRIES * sizeof(vldbentry));

        while (copy_to_vldbentry(&#38;vlentry, singleentry))
                singleentry++, vldbentries-&#62;entries_len++;
    }</pre>

<p>This is the best (and simplest) way of using variable-size arrays as an output parameter. It is the responsibility of the server-side stub to malloc() the adequate space which is automatically freed by the <b>rxgen</b> stub; the client side should free the space allocated by the <b>rxgen</b>-calling stub.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Array_example_III_(Linked_Lists)"
>Array example III (Linked Lists)</a></h3>

<p>Considering the following 3 declarations (could have applied some optimizations) in the configuration file:</p>

<pre>    typedef struct single_vldbentry *vldblist;
    struct single_vldbentry {
        vldbentry vlentry;
        vldblist  next_vldb;
    };

    struct vldb_list {
        vldblist node;
    };</pre>

<p>and the rxgen procedure declaration:</p>

<pre>    LinkedList (IN vldblistbyattributes *attributes, 
        OUT vldb_list *linkedentries) = VL_LINKEDLIST;</pre>

<p>Sample CLIENT code:</p>

<pre>    vldb_list       linkedvldbs;
    vldblist        vllist, vllist1;

    bzero(&#38;linkedvldbs, sizeof(vldb_list));
    code = VL_LinkedList(&#38;attributes, &#38;nentries, &#38;linkedvldbs);
    if (!code) {
        printf(&#34;We got %d vldb entries\n&#34;, nentries);
        for (vllist = linkedvldbs.node; vllist; vllist = vllist1) {
            vllist1 = vllist-&#62;next_vldb;
            display_entry(&#38;vllist-&#62;vlentry);
            free((char *)vllist);
        }
    }</pre>

<p>Sample SERVER code:</p>

<pre>    VL_LinkedList(rxcall, attributes, nentries, linkedvldbs);
    {
        vldblist vllist, *vllistptr = &#38;linkedvldbs-&#62;node;
        while (...) {
            vllist = *vllistptr
                = (single_vldbentry *)malloc (sizeof (single_vldbentry));
            copy_to_vldbentry(&#38;tentry, &#38;vllist-&#62;vlentry);
            nentries++;     
            vllistptr = &#38;vllist-&#62;next_vldb;
        };
        *vllistptr = NULL;
    }</pre>

<p>Using a linked list offers many advantages: Nothing is passed to the server (the parameter is OUT), no additional overhead is involved, and the caller doesn&#39;t have to explicitly prepare for an arbitrary return size. A drawback is that the caller has the responsibility of malloc() (on the server) and free (on the client) of each entry (to avoid unwanted core-leaks). Another drawback is that since it&#39;s a recursive call, the C stack will grow linearly with respect to the number of nodes in the list (so it&#39;s wise to increase the Rx LWP stack if huge amounts of data are expected back -- default stack size is 4K). The advantages should outweight the disadvantages here.</p>

<p>It&#39;s important to pay attention to the comments of the three array examples above particularly when they&#39;re references to when the user should allocate/free space for the variable length arrays. The mechanism is very similar to the handling of strings thus you might need to review the strings section above; note that the linked lists are handled somewhat differently...</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Miscellaneous_examples"
>Miscellaneous examples</a></h2>

<p>Below is an abbreviated version of a random interface file which shows some of the common cases.</p>

<pre>    /* Declaration of all structures used by the R.xg script interface */

    struct AFSFid {
        unsigned long Volume;
        unsigned long Vnode;
        unsigned long Unique;
    };

    typedef long ViceDataType;

    /* Note that TEST would be equivalent to &#34;HEADER&#34; only during the 
       processing of the header, *.h, file */

    #ifdef RPC_HDR
    #define TEST &#34;HEADER&#34;
    #else
    #define TEST &#34;REST&#34;
    #endif

    /* This is the standard *.xg specification file */

    package AFS_
    splitprefix IN=BEFORE_ OUT=AFTER_;
    Prefix Test

    proc Remove(IN struct AFSFid *Did, IN string volname&#60;64&#62;,
        OUT struct AFSStatus *Status) = AFS_REMOVE;

    DisconnectFS AUX_disconnectFS() = AFS_DISCONNECTFS;

    proc GetVolumeInfo(IN string Vid, 
        OUT struct VolumeInfo *Info) = AFS_GETVOLUMEINFO;

    /* You could have more than an interface per configuration */

    package VOTE_

    /* Using the &#34;multi&#34; feature; thus VOTE_Beacon can be called as an 
       multi-Rx call or as a regular call */

    Beacon (IN long state, long voteStart, 
        net_version *version, net_tid *tid) 
        multi = VOTE_BEACON;

    package DISK_

    /* Using the &#34;split&#34; feature */

    SendFile (IN long file, long offset, 
        long length, net_version *version) 
        split = DISK_SENDFILE;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Output_of_an_actual_interface_configuration"
>Output of an actual interface configuration</a></h2>

<p>We&#39;ll demonstrate some of the actual output generated by <b>rxgen</b> by following an abbreviated actual interface configuration.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Configuration_file"
>Configuration file</a></h3>

<p>Contents of the interface configuration file (<em>vldbint.xg</em>):</p>

<pre>    package VL_
    #include &#34;vl_opcodes.h&#34;   /* The opcodes are included here */
    %#include &#34;vl_opcodes.h&#34;  /* directly to other places */

    /* Current limitations on parameters that affect other packages
       (i.e. volume) */

    const   MAXNAMELEN      =       65;
    const   MAXNSERVERS     =       8;
    const   MAXTYPES        =       3;

    /* External (visible) representation of an individual vldb entry */

    struct vldbentry {
        char    name[MAXNAMELEN];       
        long    volumeType;             
        long    nServers;               
        long    serverNumber[MAXNSERVERS];
        long    serverPartition[MAXNSERVERS];
        long    serverFlags[MAXNSERVERS];
        u_long  volumeId[MAXTYPES];     
        long    flags;                  
    };

    typedef struct single_vldbentry  *vldblist;
    struct single_vldbentry {
        vldbentry VldbEntry;
        vldblist next_vldb;
    };

    struct vldb_list {
        vldblist node;
    };

    /* vldb interface calls */

    CreateEntry     (IN long Volid, 
                    vldbentry *newentry) = VLCREATEENTRY;

    GetEntryByName  (IN string volumename&#60;MAXNAMELEN&#62;, 
                    OUT vldbentry *entry) = VLGETENTRYBYNAME;

    GetNewVolumeId  (IN long bumpcount,
                    OUT long *newvolumid) = VLGETNEWVOLUMEID;

    ReplaceEntry    (IN long Volid, 
                    long voltype,
                    vldbentry *newentry,
                    long ReleaseType) multi = VLREPLACEENTRY;

    ListAttributes  (IN VldbListByAttributes *attributes, 
                    OUT long *nentries, 
                    OUT vldbentry bulkentries&#60;MAXVLDBLEN&#62;) 
                    = VLLISTATTRIBUTES;

    LinkedList      (IN VldbListByAttributes *attributes, 
                    OUT long *nentries, 
                    OUT vldb_list *linkedentries) = VLLINKEDLIST;</pre>

<p>We&#39;ll concentrate only on the Rx generated code since the R generated code (<b>-R</b> option) will soon be obsolete. For a detailed description on the Rx-related calls inside the generated stubs (i.e., rx_NewCall(), rx_EndCall()), along with details on what happens inside certain calls (like xdrrx_create()) please refer to the Rx documentation. Typing <code>rxgen vldbint.xg</code> will result in the creation of four files: <em>vldbint.h</em>, <em>vldbint.xdr.c</em>, <em>vldbint.cs.c</em> and <em>vldbint.ss.c</em>. A closer look at these files follows.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Header_file_(vldbint.h)"
>Header file (<em>vldbint.h</em>)</a></h3>

<pre>    /* Machine generated file -- Do NOT edit */

    #include &#34;vl_opcodes.h&#34;  /* directly to other places */
    #define MAXNAMELEN 65
    #define MAXNSERVERS 8
    #define MAXTYPES 3

    struct vldbentry {
        char name[MAXNAMELEN];
        long volumeType;
        long nServers;
        long serverNumber[MAXNSERVERS];
        long serverPartition[MAXNSERVERS];
        long serverFlags[MAXNSERVERS];
        u_long volumeId[MAXTYPES];
        long flags;
    };
    typedef struct vldbentry vldbentry;
    bool_t xdr_vldbentry();

    typedef struct single_vldbentry *vldblist;
    bool_t xdr_vldblist();

    struct single_vldbentry {
        vldbentry VldbEntry;
        vldblist next_vldb;
    };
    typedef struct single_vldbentry single_vldbentry;
    bool_t xdr_single_vldbentry();

    struct vldb_list {
        vldblist node;
    };
    typedef struct vldb_list vldb_list;
    bool_t xdr_vldb_list();

    #include &#60;rx/rx_multi.h&#62;
    #define multi_VL_ReplaceEntry(Volid, voltype, newentry, ReleaseType) \
        multi_Body(StartVL_ReplaceEntry(multi_call, Volid, voltype,
                   newentry, ReleaseType), EndVL_ReplaceEntry(multi_call))

    typedef struct bulkentries {
        u_int bulkentries_len;
        vldbentry *bulkentries_val;
    } bulkentries;
    bool_t xdr_bulkentries();

    /* Opcode-related useful stats for package: VL_ */
    #define VL_LOWEST_OPCODE        501
    #define VL_HIGHEST_OPCODE       506
    #define VL_NUMBER_OPCODES       6</pre>

<p>Notice that all structures are automatically typedef&#39;ed and all <code>const</code>s are converted to <code>#define</code>s. Some data structures, such as bulkentries, are taken from procedure params (from ListAttributes proc). Thus, this should be kept in mind when creating stubs piecemeal with <b>rxgen</b> (i.e., using the <b>-c</b>, <b>-h</b>, <b>-C</b>, or <b>-S</b> flags). Also, one of the side effects of the <code>multi</code> option (in <code>ReplaceEntry</code> proc) is the generation of the <code>multi_VL_ReplaceEntry</code> above.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="XDR_routines_for_structures_(vldbint.xdr.c)"
>XDR routines for structures (vldbint.xdr.c)</a></h3>

<pre>    /* Machine generated file -- Do NOT edit */

    #include &#60;rx/xdr.h&#62;
    #include &#34;vldbint.h&#34;

    #include &#34;vl_opcodes.h&#34;  /* directly to other places */

    bool_t
    xdr_vldbentry(xdrs, objp)
        XDR *xdrs;
        vldbentry *objp;
    {
        if (!xdr_vector(xdrs, (char *)objp-&#62;name, MAXNAMELEN,
                        sizeof(char), xdr_char))
            return (FALSE);
        if (!xdr_long(xdrs, &#38;objp-&#62;volumeType))
            return (FALSE);
        if (!xdr_long(xdrs, &#38;objp-&#62;nServers))
            return (FALSE);
        if (!xdr_vector(xdrs, (char *)objp-&#62;serverNumber, MAXNSERVERS,
                        sizeof(long), xdr_long))
            return (FALSE);
        if (!xdr_vector(xdrs, (char *)objp-&#62;serverPartition,
                        MAXNSERVERS, sizeof(long), xdr_long))
            return (FALSE);
        if (!xdr_vector(xdrs, (char *)objp-&#62;serverFlags, MAXNSERVERS,
                        sizeof(long), xdr_long))
            return (FALSE);
        if (!xdr_vector(xdrs, (char *)objp-&#62;volumeId, MAXTYPES,
                        sizeof(u_long), xdr_u_long))
            return (FALSE);
        if (!xdr_long(xdrs, &#38;objp-&#62;flags))
            return (FALSE);
        return (TRUE);
    }

    bool_t
    xdr_vldblist(xdrs, objp)
        XDR *xdrs;
        vldblist *objp;
    {
        if (!xdr_pointer(xdrs, (char **)objp,
                         sizeof(struct single_vldbentry), 
                         xdr_single_vldbentry))
            return (FALSE);
        return (TRUE);
    }

    bool_t
    xdr_single_vldbentry(xdrs, objp)
        XDR *xdrs;
        single_vldbentry *objp;
    {
        if (!xdr_vldbentry(xdrs, &#38;objp-&#62;VldbEntry))
            return (FALSE);
        if (!xdr_vldblist(xdrs, &#38;objp-&#62;next_vldb))
            return (FALSE);
        return (TRUE);
    }

    bool_t
    xdr_vldb_list(xdrs, objp)
        XDR *xdrs;
        vldb_list *objp;
    {
        if (!xdr_vldblist(xdrs, &#38;objp-&#62;node))
            return (FALSE);
        return (TRUE);
    }

    bool_t
    xdr_bulkentries(xdrs, objp)
        XDR *xdrs;
        bulkentries *objp;
    {
        if (!xdr_array(xdrs, (char **)&#38;objp-&#62;bulkentries_val,
                       (u_int *)&#38;objp-&#62;bulkentries_len, MAXVLDBLEN,
                       sizeof(vldbentry), xdr_vldbentry))
            return (FALSE);
        return (TRUE);
    }</pre>

<p>Note that the xdr_bulkentries() is automatically generated as a side effect of a procedure parameter declaration. Thus, if identical multiple type parameter declarations are used, then multiply-defined xdr_* stubs will be created! We felt this was a better alternative to having the <b>rxgen</b> programmer deal with types such as bulkentries_1, bulkentries_2...</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Client-Side_stub_routines_(vldbint.cs.c)"
>Client-Side stub routines (vldbint.cs.c)</a></h3>

<pre>    /* Machine generated file -- Do NOT edit */

    #include &#60;rx/xdr.h&#62;
    #include &#60;rx/rx.h&#62;
    #include &#60;afs/rxgen_consts.h&#62;
    #include &#34;vldbint.h&#34;

    #include &#34;vl_opcodes.h&#34;  /* directly to other places */

    int VL_CreateEntry(z_conn, Volid, newentry)
        register struct rx_connection *z_conn;
        long Volid;
        vldbentry * newentry;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 501;
        int z_result;
        XDR z_xdrs;

        xdrrx_create(&#38;z_xdrs, z_call, XDR_ENCODE);

        /* Marshal the arguments */
        if ((!xdr_int(&#38;z_xdrs, &#38;z_op))
             || (!xdr_long(&#38;z_xdrs, &#38;Volid))
             || (!xdr_vldbentry(&#38;z_xdrs, newentry))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }

        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }

    int VL_GetEntryByName(z_conn, volumename, entry)
        register struct rx_connection *z_conn;
        char * volumename;
        vldbentry * entry;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 504;
        int z_result;
        XDR z_xdrs;

        xdrrx_create(&#38;z_xdrs, z_call, XDR_ENCODE);

        /* Marshal the arguments */
        if ((!xdr_int(&#38;z_xdrs, &#38;z_op))
             || (!xdr_string(&#38;z_xdrs, &#38;volumename, 65))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }

        /* Un-marshal the reply arguments */
        z_xdrs.x_op = XDR_DECODE;
        if ((!xdr_vldbentry(&#38;z_xdrs, entry))) {
                z_result = RXGEN_CC_UNMARSHAL;
                goto fail;
        }

        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }

    int VL_GetNewVolumeId(z_conn, bumpcount, newvolumid)
        register struct rx_connection *z_conn;
        long bumpcount;
        long * newvolumid;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 505;
        int z_result;
        XDR z_xdrs;

        xdrrx_create(&#38;z_xdrs, z_call, XDR_ENCODE);

        /* Marshal the arguments */
        if ((!xdr_int(&#38;z_xdrs, &#38;z_op))
             || (!xdr_long(&#38;z_xdrs, &#38;bumpcount))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }

        /* Un-marshal the reply arguments */
        z_xdrs.x_op = XDR_DECODE;
        if ((!xdr_long(&#38;z_xdrs, newvolumid))) {
                z_result = RXGEN_CC_UNMARSHAL;
                goto fail;
        }

        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }

    int VL_ReplaceEntry(z_conn, Volid, voltype, newentry, ReleaseType)
        register struct rx_connection *z_conn;
        long Volid, voltype, ReleaseType;
        vldbentry * newentry;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 506;
        int z_result;
        XDR z_xdrs;

        xdrrx_create(&#38;z_xdrs, z_call, XDR_ENCODE);

        /* Marshal the arguments */
        if ((!xdr_int(&#38;z_xdrs, &#38;z_op))
             || (!xdr_long(&#38;z_xdrs, &#38;Volid))
             || (!xdr_long(&#38;z_xdrs, &#38;voltype))
             || (!xdr_vldbentry(&#38;z_xdrs, newentry))
             || (!xdr_long(&#38;z_xdrs, &#38;ReleaseType))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }

        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }

    int StartVL_ReplaceEntry(z_call, Volid, voltype, newentry, ReleaseType)
        register struct rx_call *z_call;
        long Volid, voltype, ReleaseType;
        vldbentry * newentry;
    {
        static int z_op = 506;
        int z_result;
        XDR z_xdrs;

        xdrrx_create(&#38;z_xdrs, z_call, XDR_ENCODE);

        /* Marshal the arguments */
        if ((!xdr_int(&#38;z_xdrs, &#38;z_op))
             || (!xdr_long(&#38;z_xdrs, &#38;Volid))
             || (!xdr_long(&#38;z_xdrs, &#38;voltype))
             || (!xdr_vldbentry(&#38;z_xdrs, newentry))
             || (!xdr_long(&#38;z_xdrs, &#38;ReleaseType))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }

        z_result = RXGEN_SUCCESS;
    fail:
        return z_result;
    }

    int EndVL_ReplaceEntry(z_call)
        register struct rx_call *z_call;
    {
        int z_result;
        XDR z_xdrs;

        z_result = RXGEN_SUCCESS;
    fail:
        return z_result;
    }

    int VL_ListAttributes(z_conn, attributes, nentries, bulkentries_1)
        register struct rx_connection *z_conn;
        VldbListByAttributes * attributes;
        long * nentries;
        bulkentries * bulkentries_1;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 511;
        int z_result;
        XDR z_xdrs;

        xdrrx_create(&#38;z_xdrs, z_call, XDR_ENCODE);

        /* Marshal the arguments */
        if ((!xdr_int(&#38;z_xdrs, &#38;z_op))
             || (!xdr_VldbListByAttributes(&#38;z_xdrs, attributes))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }

        /* Un-marshal the reply arguments */
        z_xdrs.x_op = XDR_DECODE;
        if ((!xdr_long(&#38;z_xdrs, nentries))
             || (!xdr_bulkentries(&#38;z_xdrs, bulkentries_1))) {
                z_result = RXGEN_CC_UNMARSHAL;
                goto fail;
        }

        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }

    int VL_LinkedList(z_conn, attributes, nentries, linkedentries)
        register struct rx_connection *z_conn;
        VldbListByAttributes * attributes;
        long * nentries;
        vldb_list * linkedentries;
    {
        struct rx_call *z_call = rx_NewCall(z_conn);
        static int z_op = 512;
        int z_result;
        XDR z_xdrs;

        xdrrx_create(&#38;z_xdrs, z_call, XDR_ENCODE);

        /* Marshal the arguments */
        if ((!xdr_int(&#38;z_xdrs, &#38;z_op))
             || (!xdr_VldbListByAttributes(&#38;z_xdrs, attributes))) {
                z_result = RXGEN_CC_MARSHAL;
                goto fail;
        }

        /* Un-marshal the reply arguments */
        z_xdrs.x_op = XDR_DECODE;
        if ((!xdr_long(&#38;z_xdrs, nentries))
             || (!xdr_vldb_list(&#38;z_xdrs, linkedentries))) {
                z_result = RXGEN_CC_UNMARSHAL;
                goto fail;
        }

        z_result = RXGEN_SUCCESS;
    fail:
        return rx_EndCall(z_call, z_result);
    }</pre>

<p>Notice the side effect of the <code>multi</code> feature (three different modules for <code>ReplaceEntry</code> proc).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Server-Side_stub_routines_(vldbint.ss.c)"
>Server-Side stub routines (vldbint.ss.c)</a></h3>

<pre>    /* Machine generated file -- Do NOT edit */

    #include &#60;rx/xdr.h&#62;
    #include &#60;rx/rx.h&#62;
    #include &#60;afs/rxgen_consts.h&#62;
    #include &#34;vldbint.h&#34;

    #include &#34;vl_opcodes.h&#34;  /* directly to other places */

    long _VL_CreateEntry(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        long Volid;
        vldbentry newentry;

        if ((!xdr_long(z_xdrs, &#38;Volid))
             || (!xdr_vldbentry(z_xdrs, &#38;newentry))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }

        z_result = VL_CreateEntry(z_call, Volid, &#38;newentry);
    fail:
        return z_result;
    }

    long _VL_GetEntryByName(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        char *volumename = (char *)0;
        vldbentry entry;

        if ((!xdr_string(z_xdrs, &#38;volumename, 65))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }

        z_result = VL_GetEntryByName(z_call, &#38;volumename, &#38;entry);
        z_xdrs-&#62;x_op = XDR_ENCODE;
        if ((!xdr_vldbentry(z_xdrs, &#38;entry)))
                z_result = RXGEN_SS_MARSHAL;
    fail:
        z_xdrs-&#62;x_op = XDR_FREE;
        if (!xdr_string(z_xdrs, &#38;volumename, 65)) goto fail1;
        return z_result;
    fail1:
        return RXGEN_SS_XDRFREE;
    }

    long _VL_GetNewVolumeId(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        long bumpcount;
        long newvolumid;

        if ((!xdr_long(z_xdrs, &#38;bumpcount))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }

        z_result = VL_GetNewVolumeId(z_call, bumpcount, &#38;newvolumid);
        z_xdrs-&#62;x_op = XDR_ENCODE;
        if ((!xdr_long(z_xdrs, &#38;newvolumid)))
                z_result = RXGEN_SS_MARSHAL;
    fail:
        return z_result;
    }

    long _VL_ReplaceEntry(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        long Volid, voltype, ReleaseType;
        vldbentry newentry;

        if ((!xdr_long(z_xdrs, &#38;Volid))
             || (!xdr_long(z_xdrs, &#38;voltype))
             || (!xdr_vldbentry(z_xdrs, &#38;newentry))
             || (!xdr_long(z_xdrs, &#38;ReleaseType))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }

        z_result = VL_ReplaceEntry(z_call, Volid, voltype, &#38;newentry,
                                   ReleaseType);
    fail:
        return z_result;
    }

    long _VL_ListAttributes(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        VldbListByAttributes attributes;
        long nentries;
        bulkentries bulkentries_1;

        if ((!xdr_VldbListByAttributes(z_xdrs, &#38;attributes))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }

        z_result = VL_ListAttributes(z_call, &#38;attributes, &#38;nentries,
                                     &#38;bulkentries_1);
        z_xdrs-&#62;x_op = XDR_ENCODE;
        if ((!xdr_long(z_xdrs, &#38;nentries))
             || (!xdr_bulkentries(z_xdrs, &#38;bulkentries_1)))
                z_result = RXGEN_SS_MARSHAL;
    fail:
        z_xdrs-&#62;x_op = XDR_FREE;
        if (!xdr_bulkentries(z_xdrs, &#38;bulkentries_1)) goto fail1;
        return z_result;
    fail1:
        return RXGEN_SS_XDRFREE;
    }

    long _VL_LinkedList(z_call, z_xdrs)
        struct rx_call *z_call;
        XDR *z_xdrs;
    {
        long z_result;
        VldbListByAttributes attributes;
        long nentries;
        vldb_list linkedentries;

        if ((!xdr_VldbListByAttributes(z_xdrs, &#38;attributes))) {
                z_result = RXGEN_SS_UNMARSHAL;
                goto fail;
        }

        z_result = VL_LinkedList(z_call, &#38;attributes, &#38;nentries,
                                 &#38;linkedentries);
        z_xdrs-&#62;x_op = XDR_ENCODE;
        if ((!xdr_long(z_xdrs, &#38;nentries))
             || (!xdr_vldb_list(z_xdrs, &#38;linkedentries)))
                z_result = RXGEN_SS_MARSHAL;
    fail:
        return z_result;
    }

    long _VL_CreateEntry();
    long _VL_GetEntryByName();
    long _VL_GetNewVolumeId();
    long _VL_ReplaceEntry();
    long _VL_ListAttributes();
    long _VL_LinkedList();

    static long (*StubProcsArray0[])() = {_VL_CreateEntry,
        _VL_GetEntryByName, _VL_GetNewVolumeId, _VL_ReplaceEntry,
        _VL_ListAttributes, _VL_LinkedList};

    VL_ExecuteRequest(z_call)
        register struct rx_call *z_call;
    {
        int op;
        XDR z_xdrs;
        long z_result;

        xdrrx_create(&#38;z_xdrs, z_call, XDR_DECODE);
        if (!xdr_int(&#38;z_xdrs, &#38;op))
            z_result = RXGEN_DECODE;
        else if (op &#60; VL_LOWEST_OPCODE || op &#62; VL_HIGHEST_OPCODE)
            z_result = RXGEN_OPCODE;
        else
            z_result = (*StubProcsArray0[op - VL_LOWEST_OPCODE])
                (z_call, &#38;z_xdrs);
        return z_result;
    }</pre>

<p>If there were gaps in the procedures&#39; opcode sequence the code for VL_ExecuteRequest() routine would be have been drastically different (it would have been a case statement for each procedure).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES"
>NOTES</a></h1>

<p><b>rxgen</b> is implemented from Sun&#39;s <b>rpcgen</b> utility. All of the standard <b>rpcgen</b>&#39;s functionality is fully maintained. Note that some active <b>rpcgen</b> options that don&#39;t apply to <b>rxgen</b>&#39;s purpose aren&#39;t referenced here (i.e., <b>-s</b>, <b>-l</b>, <b>-m</b> options) and the interested reader should refer to rpcgen(1) for details.</p>

<p>When the <code>%#include &#60;include file</code>&#62; feature is used make sure that you don&#39;t have any <b>rxgen</b> language features (i.e. %#defines) since you&#39;ll get syntax errors during compilations..</p>

<p>Since this is an ongoing project many of the above may change/disappear without a major warning.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><i>Rxgen Syntax Summary</i>: Summary description of rxgen&#39;s grammar.</p>

<p><i>Rpcgen Programming Guide</i>: Sun&#39;s RPC protocol compiler. <b>rxgen</b> was implemented as an extension to that compiler.</p>

<p><i>External Data Representation: Sun Technical Notes</i>: Detailed examples in using XDR.</p>

<p><i>RPCL Syntax Summary</i>: Summary of Sun&#39;s Remote Procedure Call Language.</p>

<p><i>Rx</i>: An extended Remote Procedure Call Protocol.</p>

<p><i>rgen</i>: An earlier version of a similar stub generator used for the R RPC protocol.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>IBM Corporation 2000. &#60;http://www.ibm.com/&#62; All Rights Reserved.</p>

<p>This documentation is covered by the IBM Public License Version 1.0. It was converted from the original TeX <b>rxgen</b> manual to POD by Russ Allbery.</p>

<!-- end doc -->

</body></html>
